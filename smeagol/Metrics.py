

##############################################
# on-line metrics to estimate performance.
##############################################

import numpy as np

from scipy.spatial.distance import cdist


def prepare_predictions(predicted_labels):
  '''
    Transform the labels returned by RingFinder.eval for use in metrics.
  '''

  return [[[p[0],p[1],r[0]] for r in e for p in r[1]] for e in predicted_labels]


def prepare_actuals(actual_labels,screen):
  '''
    Transform the MultiVariedRingGenerator labels for use in metrics.
    Parameters
    ---------
    actual_labels - labels returned by the MultiVariedRingGenerator
    screen - a screen object to transform coordinates.
  '''

  labels = []

  for e in actual_labels:
    p = screen.transform_index(np.array([d[0] for d in e]))
    labels.append([[p[i][0],p[i][1],e[i][1]] for i in range(len(e))])

  return labels


def match_prediction(y_true,y_hat):

  N = len(y_true)

  near_ = 2
  band_ = 0.1

  true_positives = []
  false_positives = []

  # cycle over images
  for i in range(N):
    p = np.array(y_hat[i])
    a = np.array(y_true[i])

    sdists = cdist(p[:,:2],a[:,:2])
    rdists = cdist(p[:,-1:],a[:,-1:],metric='cityblock')

    res = np.where((sdists < near_) & (rdists < band_))

    tpi,tpii = np.unique(res[1],return_index=True)

    true_pos =a[tpi,:]
    fpi = [j for j in np.arange(p.shape[0]) if j not in res[0] or j not in tpii]
    false_pos = p[fpi,:]

    true_positives.append(true_pos)
    false_positives.append(false_pos)

  return true_positives,false_positives
     

def binary_score(y_true,y_hat):
  '''
    Return a binary (1/0 for true/false positive) for each y_hat,
    and another binary (1/0 for found/not found) for each y_true to indicate false_negatives.
    Parameters
    ---------
    y_true - list of list of actual ring labels (e.g. output of prepare_actuals)
    y_hat - list of list of predicted ring labels (e.g. output of prepare predictions)
   
    Returns
    -------
    binary positive indicator
    binary negative indicator
  '''

  near_ = 2.
  band_ = 0.1

  tp_ = 0
  fp_ = 0
  fn_ = 0
  pcount_ = 0

  def dmetric(x,y,near_ = 2,band_ = 0.1):
    return np.array([np.linalg.norm(x[:1]-y[:1]),np.abs(x[2]-y[2])])

  N = len(y_true)

  true_positives_ = []
  false_positives_ = []
  false_negatives_ = []

  # loop over all events
  for i in range(N):
    # get the labels for this event
    labels = np.array(y_true[i])
    preds = np.array(y_hat[i])

    # find the nearest prediction to each label
    #dists =   
    # map of labels to predictions array
    dmap = -1.*np.ones(len(labels))

    if len(preds) > 0:
      for j in range(len(labels)):
        lab = labels[j]
        dists = np.array([np.linalg.norm(np.array(lab[:1])-np.array(p[:1])) for p in preds])
        ind = np.argmin(dists)
        if dists[ind] < near_ and np.abs(preds[ind][2]-lab[2]) <= band_:
          dmap[j] = ind


      tp_ += len(dmap[dmap > -1])
      fp_ += len(set(list(range(len(preds)))).difference(set(list(dmap[dmap>-1]))))
      fn_ += len(dmap[dmap == -1])      
    
    else:
      fp_ += 0
      tp_ += 0
      fn_ += len(labels)


    # count the number of matches
    pcount_ += len(labels)
  
  assert tp_ + fn_  == pcount_
   
  return dmap 
  

class metric_accumulator(object):
  '''Accumulate true/false positive/negative counts.'''


  def __init__(self):

    self.band_ = 0.1
    self.near_ = 2
    
    self.tp_ = 0
    self.fp_ = 0
    self.fn_ = 0
    self.pcount_ = 0

  def partial_fit(self,y_true,y_hat):
    '''Determine and increment the true positive, true negative, and false negative counts given the matching criteria.'''

    # assume y_true and y_hat have the following form
    # NxM where there are N events and M in an event.
    # This is a list of lists, not a matrix since M varies from event to events.
    # The elements of M are np array (x,y,r)


    # y_true are the labels generated by the ring generator
    # y_hat are the labels generated by the kernel convolver

    # get the number of events
    N = len(y_true)
    assert N == len(y_hat)

    # loop over all events
    for i in range(N):
      # get the labels for this event
      labels = y_true[i]

      # find the nearest prediction to each label
      preds = y_hat[i]

      # map of labels to predictions array
      dmap = -1.*np.ones(len(labels))

      if len(preds) > 0:
        for j in range(len(labels)):
          lab = labels[j]
          dists = np.array([np.linalg.norm(np.array(lab[:1])-np.array(p[:1])) for p in preds])
          ind = np.argmin(dists)
          if dists[ind] < self.near_ and np.abs(preds[ind][2]-lab[2]) <= self.band_:
            dmap[j] = ind


        self.tp_ += len(dmap[dmap > -1])
        self.fp_ += len(set(list(range(len(preds)))).difference(set(list(dmap[dmap>-1]))))
        self.fn_ += len(dmap[dmap == -1])      
    
      else:
        self.fp_ += 0
        self.tp_ += 0
        self.fn_ += len(labels)


      # count the number of matches
      self.pcount_ += len(labels)
  
    assert self.tp_ + self.fn_  == self.pcount_




#
# calculate some specific metric using the metric accumulator
class F1(metric_accumulator):

  def __init__(self):
    super(F1,self).__init__()

  def score(self):
    '''return the F1 score.'''

    # precision
    p = np.float64(self.tp_)/(self.tp_+self.fp_)

    # recall
    r = np.float64(self.tp_)/(self.pcount_)

    return 2.*p*r/(p+r)



####
# Some old online metrics.

class ROC(object):

  def __init__(self,N=1000,r=[0.,1.]):

    self.N_ = int(N)
    self.range_ = tuple(r)

    self.tp_rate_ = np.zeros(N)
    self.fp_rate_ = np.zeros(N)
    self.count_ = 0.
    self.total_ = 0.

    db = (self.range_[1]-self.range_[0])/float(self.N_)
    self.bins_ = np.array([i*db for i in range(N)][::-1])

    self.is_finished_ = False

  def partial_fit(self,y_true,y_hat):

    y_hat = np.array(y_hat).flatten()
    y_true = np.array(y_true).flatten()
    assert y_hat.shape == y_true.shape

    y_true = (y_true == 1)

    sort_indx = np.argsort(y_hat,kind='mergesort')[::-1]
    y_true = np.array([0] + list(y_true[sort_indx]))
    y_hat = y_hat[sort_indx]

    # find the max index where y_hat is >= threshold
    thrs_indx = np.array([np.argwhere(y_hat >= tr)[-1] + 1 if len(y_hat[y_hat >= tr]) > 0 else 0 for tr in self.bins_]).flatten()

    self.tp_rate_ += np.cumsum(y_true)[thrs_indx]
    self.fp_rate_ += thrs_indx - 1
    self.count_ += np.sum(y_true,dtype=np.float64)
    self.total_ += len(y_hat)

  def finish(self):

    if not self.is_finished_:
      self.fp_rate_ -= self.tp_rate_
      self.tp_rate_ /= np.float64(self.count_)
      self.fp_rate_ /= np.float64(self.total_)
      self.is_finished_ = True

  def getROC(self):

    self.finish()

    return self.tp_rate_,self.fp_rate_
 




class Mathews(object):

  def __init__(self,pos_class = 1):

    self.count_ = 0.
    self.tp_ = 0.
    self.tn_ = 0.
    self.fp_ = 0.
    self.fn_ = 0.

    self.pos_class_ = pos_class

  def partial_fit(self,y_true,y_hat):
  
    y_true = np.array(y_true).flatten()
    y_hat = np.array(y_hat).flatten()

    assert y_true.shape == y_hat.shape

    self.count_ += len(y_true)

    # assume y_hat can be cast to a boolean (i.e. scoring theshold has already been applied)
    y_true = (y_true == self.pos_class_)
    y_hat = (y_hat == self.pos_class_)

    self.count_ += y_true.shape[0]

    self.tp_ += np.sum((y_hat == True) & (y_true == True))
    self.tn_ += np.sum((y_hat == False) & (y_true == False))
    self.fp_ += np.sum((y_hat == True) & (y_true == False))
    self.fn_ += np.sum((y_hat == False) & (y_true == True))

  def getMathews(self):
    return (self.tp_*self.tn_ - self.fp_*self.fn_)/np.sqrt((self.tp_+self.fp_)*(self.tp_+self.fn_)*(self.tn_+self.fp_)*(self.tn_+self.fn_))



