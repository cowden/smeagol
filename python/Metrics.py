

##############################################
# on-line metrics to estimate performance.
##############################################

import numpy as np



class metric_accumulator(object):
  '''Accumulate true/false positive/negative counts.'''


  def __init__(self):

    self.band_ = 0.1
    self.near_ = 2
    
    self.tp_ = 0
    self.fp_ = 0
    self.fn_ = 0
    self.pcount_ = 0

  def partial_fit(self,y_true,y_hat):
    '''Determine and increment the true positive, true negative, and false negative counts given the matching criteria.'''

    # assume y_true and y_hat have the following form
    # NxM where there are N events and M in an event.
    # This is a list of lists, not a matrix since M varies from event to events.
    # The elements of M are np array (x,y,r)


    # y_true are the labels generated by the ring generator
    # y_hat are the labels generated by the kernel convolver

    # get the number of events
    N = len(y_true)
    assert N == len(y_hat)

    # loop over all events
    for i in range(N):
      # get the labels for this event
      labels = y_true[i]

      # find the nearest prediction to each label
      preds = y_hat[i]

      # map of labels to predictions array
      dmap = -1.*np.ones(len(labels))

      if len(preds) > 0:
        for j in range(len(labels)):
          lab = labels[j]
          dists = np.array([np.linalg.norm(np.array(lab[:1])-np.array(p[:1])) for p in preds])
          ind = np.argmin(dists)
          if dists[ind] < self.near_ and np.abs(preds[ind][2]-lab[2]) <= self.band_:
            dmap[j] = ind


        self.tp_ += len(dmap[dmap > -1])
        self.fp_ += len(set(list(range(len(preds)))).difference(set(list(dmap[dmap>-1]))))
        self.fn_ += len(dmap[dmap == -1])      
    
      else:
        self.fp_ += 0
        self.tp_ += 0
        self.fn_ += len(labels)


      # count the number of matches
      self.pcount_ += len(labels)
  
    assert self.tp_ + self.fn_  == self.pcount_




#
# calculate some specific metric using the metric accumulator
class F1(metric_accumulator):

  def __init__(self):
    super(F1,self).__init__()

  def score(self):
    '''return the F1 score.'''

    # precision
    p = np.float64(self.tp_)/(self.tp_+self.fp_)

    # recall
    r = np.float64(self.tp_)/(self.pcount_)

    return 2.*p*r/(p+r)



####
# Some old online metrics.

class ROC(object):

  def __init__(self,N=1000,r=[0.,1.]):

    self.N_ = int(N)
    self.range_ = tuple(r)

    self.tp_rate_ = np.zeros(N)
    self.fp_rate_ = np.zeros(N)
    self.count_ = 0.
    self.total_ = 0.

    db = (self.range_[1]-self.range_[0])/float(self.N_)
    self.bins_ = np.array([i*db for i in range(N)][::-1])

    self.is_finished_ = False

  def partial_fit(self,y_true,y_hat):

    y_hat = np.array(y_hat).flatten()
    y_true = np.array(y_true).flatten()
    assert y_hat.shape == y_true.shape

    y_true = (y_true == 1)

    sort_indx = np.argsort(y_hat,kind='mergesort')[::-1]
    y_true = np.array([0] + list(y_true[sort_indx]))
    y_hat = y_hat[sort_indx]

    # find the max index where y_hat is >= threshold
    thrs_indx = np.array([np.argwhere(y_hat >= tr)[-1] + 1 if len(y_hat[y_hat >= tr]) > 0 else 0 for tr in self.bins_]).flatten()

    self.tp_rate_ += np.cumsum(y_true)[thrs_indx]
    self.fp_rate_ += thrs_indx - 1
    self.count_ += np.sum(y_true,dtype=np.float64)
    self.total_ += len(y_hat)

  def finish(self):

    if not self.is_finished_:
      self.fp_rate_ -= self.tp_rate_
      self.tp_rate_ /= np.float64(self.count_)
      self.fp_rate_ /= np.float64(self.total_)
      self.is_finished_ = True

  def getROC(self):

    self.finish()

    return self.tp_rate_,self.fp_rate_
 




class Mathews(object):

  def __init__(self,pos_class = 1):

    self.count_ = 0.
    self.tp_ = 0.
    self.tn_ = 0.
    self.fp_ = 0.
    self.fn_ = 0.

    self.pos_class_ = pos_class

  def partial_fit(self,y_true,y_hat):
  
    y_true = np.array(y_true).flatten()
    y_hat = np.array(y_hat).flatten()

    assert y_true.shape == y_hat.shape

    self.count_ += len(y_true)

    # assume y_hat can be cast to a boolean (i.e. scoring theshold has already been applied)
    y_true = (y_true == self.pos_class_)
    y_hat = (y_hat == self.pos_class_)

    self.count_ += y_true.shape[0]

    self.tp_ += np.sum((y_hat == True) & (y_true == True))
    self.tn_ += np.sum((y_hat == False) & (y_true == False))
    self.fp_ += np.sum((y_hat == True) & (y_true == False))
    self.fn_ += np.sum((y_hat == False) & (y_true == True))

  def getMathews(self):
    return (self.tp_*self.tn_ - self.fp_*self.fn_)/np.sqrt((self.tp_+self.fp_)*(self.tp_+self.fn_)*(self.tn_+self.fp_)*(self.tn_+self.fn_))
